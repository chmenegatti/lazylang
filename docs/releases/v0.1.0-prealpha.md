# lazylang v0.1.0-prealpha

_Date: 2026-01-13_

## TL;DR
- Primeira publicação pública do pipeline inicial: lexer, parser parcial, SEMA endurecida e codegen C geram binário nativo mínimo.
- Runtime próprio isolado (`lz_string`, `lz_result`, `lz_maybe`, helpers `lz_assign_*`, `lz_runtime_log`) estabelece contrato de ownership que viabiliza ARC futuro sem quebrar o backend atual.
- Build e ferramentas padronizados: `make` produz `lazylangc`, fallback automático para `cc` quando `clang` não está disponível.

## Destaques

### SEMA alinhada ao backend real
- Enforça que structs usem apenas tipos primitivos suportados; impede `result`/`maybe` aninhados em campos até que o runtime evolua.
- Bloqueia construções ainda não suportadas (ex.: `for in`, `task`, `future`, `chan`) e mistura de `result` e `maybe` na mesma função, evitando geração de C inválido.
- Valida chamadas de builtin (como `log`) e garante que `main` tenha assinatura compatível com o backend.

### Runtime mínimo documentado
- `src/runtime/runtime.{h,c}` concentra todo o código compartilhado e define invariantes claros sobre ownership de `lz_string`, pontos únicos de mutação (`lz_assign_*`) e ausência de validações semânticas no runtime.
- Todo acesso a memória passa por `lz_runtime_alloc`, simplificando instrumentações futuras (ARC, métricas, hooks de diagnósticos) sem afetar o código gerado.

### Codegen e toolchain solidificados
- Código C emitido inclui automaticamente o runtime, mapeando `log` para `lz_runtime_log` e delegando atribuições aos helpers corretos.
- `lazylangc` compila o C gerado e o runtime em um único passo; se `clang` não estiver presente, utiliza `cc` para manter a experiência consistente.
- `Makefile` atualizado empacota o runtime durante `make`/`make clean`, garantindo builds reproduzíveis.

## Como experimentar
1. Requisitos: compilador C compatível com ISO C11 (clang ou cc) e `make`.
2. Build: `make` gera o binário `lazylangc` em `./lazylangc`.
3. Compile um programa `.lz`: `./lazylangc sample.lz` produz `lazylang_out.c` e `./lazylang_out`.
4. Execute `./lazylang_out` para rodar o binário nativo.

## Limitações conhecidas
- Apenas um subconjunto da especificação em [docs/language-spec.md](../language-spec.md) está implementado; `for in`, concorrência (`task`, `future`, `chan`), atualizações de struct (`with`) e ARC ainda não existem no backend.
- `result` e `maybe` só podem aparecer como tipos de retorno; structs e variáveis locais ainda seguem restrições adicionais impostas pela SEMA.
- O runtime é síncrono e não realiza nenhuma verificação dinâmica além das previstas; invariantes violados devem ser pegos pela SEMA.
- Sem sistema de módulos, import/export ou CLI de pacote; o compilador trabalha com um único arquivo de entrada.

## Próximos passos (alto nível)
1. Expandir parser/AST para cobrir toda a gramática descrita na especificação oficial.
2. Evoluir o runtime para suportar strings alocadas e preparar terreno para ARC.
3. Implementar sistema de módulos e surface mínima de `result`/`maybe` idiomática.
4. Liberar toolchain para múltiplos arquivos e adicionar suíte de testes automatizada.

---
Para detalhes completos de linguagem e invariantes, consulte o documento canônico em [docs/language-spec.md](../language-spec.md). Feedback, issues e discussões são muito bem-vindos antes da fase alpha.
